`timescale 1ns / 1ps

`include "uvm_macros.svh"
import uvm_pkg::*;

class apb_config extends uvm_object;
  `uvm_object_utils(apb_config)
  
  function new(string name = "apb_config");
    super.new(name);
  endfunction
  
  uvm_active_passive_enum is_active = UVM_ACTIVE;
  
endclass

typedef enum bit [1:0] {readd = 0, writed = 1, rst = 2} oper_mode;

class transaction extends uvm_sequence_item;
  `uvm_object_utils(transaction)
  
  rand oper_mode op;
  rand logic PWRITE;
  rand logic [31:0] PADDR;
  rand logic [31:0] PWDATA;
  logic [31:0] PRDATA;
  logic PREADY, PSLVERR;
  
  function new(string name = "transaction");
    super.new(name);
  endfunction
  
  constraint addr_c {PADDR <= 31;}
  constraint addr_c_err {PADDR > 31;}

endclass

///////////////////////////////////////////////////////////////

class write_data extends uvm_sequence#(transaction);
  `uvm_object_utils(write_data)
  
  transaction tr;
  
  function new(string name = "write_data");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      tr.addr_c.constraint_mode(1);
      tr.addr_c_err.constraint_mode(0);
      assert(tr.randomize);
      tr.op = writed;
      finish_item(tr);
    end
  endtask
  
endclass

class read_data extends uvm_sequence#(transaction);
  `uvm_object_utils(read_data)
  
  transaction tr;
  
  function new(string name = "read_data");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      tr.addr_c.constraint_mode(1);
      tr.addr_c_err.constraint_mode(0);
      assert(tr.randomize);
      tr.op = readd;
      finish_item(tr);
    end
  endtask
  
endclass

class write_read extends uvm_sequence#(transaction);
  `uvm_object_utils(write_read)
  
  transaction tr;
  
  function new(string name = "write_read");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      tr.addr_c.constraint_mode(1);
      tr.addr_c_err.constraint_mode(0);
      
      start_item(tr);
      assert(tr.randomize);
      tr.op = writed;  
      finish_item(tr);
      
      start_item(tr);      
      assert(tr.randomize);
      tr.op = readd;  
      finish_item(tr);
    end
  endtask
  
endclass

class writeb_readb extends uvm_sequence#(transaction);
  `uvm_object_utils(writeb_readb)
  
  transaction tr;
  
  function new(string name = "writeb_readb");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      tr.addr_c.constraint_mode(1);
      tr.addr_c_err.constraint_mode(0);
      
      start_item(tr);
      assert(tr.randomize);
      tr.op = writed;
      finish_item(tr);
    end
    
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      tr.addr_c.constraint_mode(1);
      tr.addr_c_err.constraint_mode(0);
      
      start_item(tr);
      assert(tr.randomize);
      tr.op = readd;
      finish_item(tr);
    end
  endtask
  
endclass

class write_err extends uvm_sequence#(transaction);
  `uvm_object_utils(write_err)
  
  transaction tr;
  
  function new(string name = "write_err");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      tr.addr_c.constraint_mode(0);
      tr.addr_c_err.constraint_mode(1);
      assert(tr.randomize);
      tr.op = writed;
      finish_item(tr);
    end
  endtask
  
endclass

class read_err extends uvm_sequence#(transaction);
  `uvm_object_utils(read_err)
  
  transaction tr;
  
  function new(string name = "read_err");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");
      start_item(tr);
      tr.addr_c.constraint_mode(0);
      tr.addr_c_err.constraint_mode(1);
      assert(tr.randomize);
      tr.op = readd;
      finish_item(tr);
    end
  endtask
  
endclass

class reset_dut extends uvm_sequence#(transaction);
  `uvm_object_utils(reset_dut)
  
  transaction tr;
  
  function new(string name = "reset_dut");
    super.new(name);
  endfunction
  
  virtual task body();
    repeat(15) begin
      tr = transaction::type_id::create("tr");  
      start_item(tr);
      assert(tr.randomize);
      tr.op = rst;
      finish_item(tr);
    end
  endtask
  
endclass

///////////////////////////////////////////////////////////////

class driver extends uvm_driver#(transaction);
  `uvm_component_utils(driver)
  
  transaction tr;
  virtual apb_if vif;
  
  function new(string name = "driver", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    tr = transaction::type_id::create("tr");
    
    if(!uvm_config_db #(virtual apb_if)::get(this,"","vif",vif))
      `uvm_error("DRV", "Unable to access Interface")
  endfunction
  
  task reset_dut();
    repeat(5) begin
      vif.presetn <= 1'b0;  
      vif.pwrite <= 'b0;
      vif.psel <= 'b0;
      vif.penable <= 'b0;
      vif.pwdata <= 'h0;
      vif.paddr <= 'h0;
      `uvm_info("DRV", "System Reset : Start of Simulation", UVM_MEDIUM);
      @(posedge vif.pclk);
    end
  endtask
      
  task drive();
    reset_dut();
    
    forever begin
      seq_item_port.get_next_item(tr);
      
      if(tr.op == rst) begin
      	vif.presetn <= 1'b0;
        vif.pwrite <= 'b0;
      	vif.psel <= 'b0;
      	vif.penable <= 'b0;
      	vif.pwdata <= 'h0;
      	vif.paddr <= 'h0;
        @(posedge vif.pclk);
      end
      
      else if(tr.op == writed) begin
          vif.presetn <= 1'b1;
          vif.psel <= 1'b1;
          vif.pwrite <= 1'b1;
          vif.paddr <= tr.PADDR;
          vif.pwdata <= tr.PWDATA;
        @(posedge vif.pclk);
          vif.penable <= 1'b1;
        `uvm_info("DRV", $sformatf("mode:%0s, addr:%0d, wdata:%0d, rdata:%0d, slverr:%0d",tr.op.name(),tr.PADDR,tr.PWDATA,tr.PRDATA,tr.PSLVERR), UVM_NONE)
          @(negedge vif.pready);    
          vif.penable <= 1'b0;  
      end
                                   
      else if(tr.op == readd) begin
          vif.presetn <= 1'b1;
          vif.psel <= 1'b1;
          vif.pwrite <= 1'b0;
          vif.paddr <= tr.PADDR;
        @(posedge vif.pclk);
          vif.penable <= 1'b1;
        `uvm_info("DRV", $sformatf("mode:%0s, addr:%0d, wdata:%0d, rdata:%0d, slverr:%0d",tr.op.name(),tr.PADDR,tr.PWDATA,tr.PRDATA,tr.PSLVERR), UVM_NONE)
          @(negedge vif.pready);    
          vif.penable <= 1'b0;
      end
      seq_item_port.item_done();
    end
    
  endtask
  
  virtual task run_phase(uvm_phase phase);
    drive();
  endtask
    
endclass
        ///////////////////////////////////////////////////////////////

class mon extends uvm_monitor;   
  `uvm_component_utils(mon)
  
  transaction tr;
  virtual apb_if vif;
  uvm_analysis_port #(transaction) send;
  
  function new(string name = "mon", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    tr = transaction::type_id::create("tr");
    send = new("send", this);
    
    if(!uvm_config_db #(virtual apb_if)::get(this,"","vif",vif))
      `uvm_error("MON", "Unable to access Interface")
  endfunction  
      
  virtual task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.pclk);
      if(vif.presetn == 1'b0) begin
        tr.op = rst;
        `uvm_info("MON", "SYSTEM RESET DETECTED", UVM_NONE);
        send.write(tr);
      end
      
      else if(vif.presetn && vif.pwrite) begin
        @(posedge vif.pready);
        tr.PSLVERR = vif.pslverr;
        @(negedge vif.pready);
        tr.op = writed;
        tr.PADDR = vif.paddr;
        tr.PWDATA = vif.pwdata;
        `uvm_info("MON", $sformatf("DATA WRITE addr:%0d data:%0d slverr:%0d",tr.PADDR,tr.PWDATA,tr.PSLVERR), UVM_NONE); 
        send.write(tr);
      end
      
      else if(vif.presetn && !vif.pwrite) begin
        @(posedge vif.pready);
        tr.PSLVERR = vif.pslverr;
        @(negedge vif.pready);
        tr.op = readd;
        tr.PADDR = vif.paddr;
        tr.PRDATA = vif.prdata;
        `uvm_info("MON", $sformatf("DATA READ addr:%0d data:%0d, slverr:%0d",tr.PADDR,tr.PRDATA,tr.PSLVERR), UVM_NONE); 
        send.write(tr);
      end
    end
  endtask
    
endclass
        ///////////////////////////////////////////////////////////////
    
class sco extends uvm_scoreboard;
  `uvm_component_utils(sco)
  
  uvm_analysis_imp #(transaction, sco) recv;
  logic [31:0] arr[32] = '{default:0};
  logic [31:0] addr = 0;
  logic [31:0] data_rd = 0;
  
  function new(string name = "sco", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    recv = new("recv", this);
  endfunction  
  
  virtual function void write(transaction tr);
    if(tr.op == rst) 
      `uvm_info("SCO", "SYSTEM RESET DETECTED", UVM_NONE)
    
    else if(tr.op == writed) begin
      if(tr.PSLVERR) 
        `uvm_info("SCO", "SLV ERROR during WRITE OP", UVM_NONE)     	else begin
        arr[tr.PADDR] = tr.PWDATA;
        `uvm_info("SCO", $sformatf("DATA WRITE OP addr:%0d wdata:%0d arr_wr:%0d",tr.PADDR,tr.PWDATA,arr[tr.PADDR]), UVM_NONE); 
      end
    end
    
    else if(tr.op == readd) begin
      if(tr.PSLVERR) 
      	`uvm_info("SCO", "SLV ERROR during READ OP", UVM_NONE)
	  else begin
        data_rd = arr[tr.PADDR];
        if(data_rd == tr.PRDATA) 
          `uvm_info("SCO", $sformatf("DATA MATCHED addr:%0d rdata:%0d",tr.PADDR,tr.PRDATA), UVM_NONE) 
        else 
          `uvm_info("SCO", $sformatf("TEST FAILED addr:%0d rdata:%0d",tr.PADDR,tr.PRDATA), UVM_NONE)   
      end
    end
        
    $display("----------------------------------------------------------------");
  endfunction
  
        
endclass
          ///////////////////////////////////////////////////////////////
        
class agent extends uvm_agent;
  `uvm_component_utils(agent)
  
  uvm_sequencer#(transaction) seqr;
  driver d;
  mon m;
  apb_config cfg;
  
  function new(string name = "agent", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    m = mon::type_id::create("m", this);    
    cfg = apb_config::type_id::create("cfg");
    
    if(cfg.is_active == UVM_ACTIVE) begin
      seqr = uvm_sequencer#(transaction)::type_id::create("seqr", this);
      d = driver::type_id::create("d", this);
    end
  endfunction            
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    if(cfg.is_active == UVM_ACTIVE)
	    d.seq_item_port.connect(seqr.seq_item_export);    
  endfunction
  
endclass
          ///////////////////////////////////////////////////////////////
  
class env extends uvm_env;
  `uvm_component_utils(env)
  
  agent a;
  sco s;
  
  function new(string name = "agent", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    a = agent::type_id::create("a", this);    
    s = sco::type_id::create("s", this);
  endfunction   	        
  
  virtual function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
    a.m.send.connect(s.recv);    
  endfunction
      
endclass
          ///////////////////////////////////////////////////////////////
      
class test extends uvm_test;
  `uvm_component_utils(test)
  
  env e;
  
  write_data wdata;
  read_data rdata;
  write_read wrrd;
  writeb_readb wrrdb;
  write_err werr;
  read_err rerr;
  reset_dut rstdut;
  
  function new(string name = "agent", uvm_component parent = null);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    e = env::type_id::create("e", this);  
    
    wdata = write_data::type_id::create("wdata");
    rdata = read_data::type_id::create("rdata");
    wrrd = write_read::type_id::create("wrrd");
    wrrdb = writeb_readb::type_id::create("wrrdb");
    werr = write_err::type_id::create("werr");
    rerr = read_err::type_id::create("rerr");
    rstdut = reset_dut::type_id::create("rstdut");

  endfunction   
  
  virtual task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    rerr.start(e.a.seqr);
    #20;
    phase.drop_objection(this);

  endtask
  
endclass
        ///////////////////////////////////////////////////////////////
        
module tb;
	
  apb_if vif();
  apb_ram dut (.presetn(vif.presetn), .pclk(vif.pclk), .psel(vif.psel), .penable(vif.penable), .pwrite(vif.pwrite), .paddr(vif.paddr), .pwdata(vif.pwdata), .prdata(vif.prdata), .pready(vif.pready), .pslverr(vif.pslverr));
  
  initial begin
    vif.pclk <= 0;
  end
  
  always #10 vif.pclk = ~vif.pclk;
  
  initial begin
    uvm_config_db #(virtual apb_if)::set(null,"*","vif",vif);
    run_test("test");
  end
  
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars;
  end
  
endmodule
